"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3706],{45999:function(e,t,r){let n,i;/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */Object.defineProperty(t,"__esModule",{value:!0}),t.utils=t.schnorr=t.verify=t.signSync=t.sign=t.getSharedSecret=t.recoverPublicKey=t.getPublicKey=t.Signature=t.Point=t.CURVE=void 0;let o=r(69159),a=BigInt(0),s=BigInt(1),c=BigInt(2),l=BigInt(3),u=BigInt(8),d=Object.freeze({a:a,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:s,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")});t.CURVE=d;let divNearest=(e,t)=>(e+t/c)/t,f={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(e){let{n:t}=d,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-s*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=BigInt("0x100000000000000000000000000000000"),a=divNearest(r*e,t),c=divNearest(-n*e,t),l=mod(e-a*r-c*i,t),u=mod(-a*n-c*r,t),f=l>o,h=u>o;if(f&&(l=t-l),h&&(u=t-u),l>o||u>o)throw Error("splitScalarEndo: Endomorphism failed, k="+e);return{k1neg:f,k1:l,k2neg:h,k2:u}}};function weierstrass(e){let{a:t,b:r}=d,n=mod(e*e),i=mod(n*e);return mod(i+t*e+r)}let h=d.a===a;let ShaError=class ShaError extends Error{constructor(e){super(e)}};function assertJacPoint(e){if(!(e instanceof JacobianPoint))throw TypeError("JacobianPoint expected")}let JacobianPoint=class JacobianPoint{constructor(e,t,r){this.x=e,this.y=t,this.z=r}static fromAffine(e){if(!(e instanceof Point))throw TypeError("JacobianPoint#fromAffine: expected Point");return e.equals(Point.ZERO)?JacobianPoint.ZERO:new JacobianPoint(e.x,e.y,s)}static toAffineBatch(e){let t=function(e,t=d.P){let r=Array(e.length),n=e.reduce((e,n,i)=>n===a?e:(r[i]=e,mod(e*n,t)),s),i=invert(n,t);return e.reduceRight((e,n,i)=>n===a?e:(r[i]=mod(e*r[i],t),mod(e*n,t)),i),r}(e.map(e=>e.z));return e.map((e,r)=>e.toAffine(t[r]))}static normalizeZ(e){return JacobianPoint.toAffineBatch(e).map(JacobianPoint.fromAffine)}equals(e){assertJacPoint(e);let{x:t,y:r,z:n}=this,{x:i,y:o,z:a}=e,s=mod(n*n),c=mod(a*a),l=mod(t*c),u=mod(i*s),d=mod(mod(r*a)*c),f=mod(mod(o*n)*s);return l===u&&d===f}negate(){return new JacobianPoint(this.x,mod(-this.y),this.z)}double(){let{x:e,y:t,z:r}=this,n=mod(e*e),i=mod(t*t),o=mod(i*i),a=e+i,s=mod(c*(mod(a*a)-n-o)),d=mod(l*n),f=mod(d*d),h=mod(f-c*s),y=mod(d*(s-h)-u*o),p=mod(c*t*r);return new JacobianPoint(h,y,p)}add(e){assertJacPoint(e);let{x:t,y:r,z:n}=this,{x:i,y:o,z:s}=e;if(i===a||o===a)return this;if(t===a||r===a)return e;let l=mod(n*n),u=mod(s*s),d=mod(t*u),f=mod(i*l),h=mod(mod(r*s)*u),y=mod(mod(o*n)*l),p=mod(f-d),g=mod(y-h);if(p===a)return g===a?this.double():JacobianPoint.ZERO;let m=mod(p*p),b=mod(p*m),w=mod(d*m),v=mod(g*g-b-c*w),P=mod(g*(w-v)-h*b),S=mod(n*s*p);return new JacobianPoint(v,P,S)}subtract(e){return this.add(e.negate())}multiplyUnsafe(e){let t=JacobianPoint.ZERO;if("bigint"==typeof e&&e===a)return t;let r=normalizeScalar(e);if(r===s)return this;if(!h){let e=t,n=this;for(;r>a;)r&s&&(e=e.add(n)),n=n.double(),r>>=s;return e}let{k1neg:n,k1:i,k2neg:o,k2:c}=f.splitScalar(r),l=t,u=t,d=this;for(;i>a||c>a;)i&s&&(l=l.add(d)),c&s&&(u=u.add(d)),d=d.double(),i>>=s,c>>=s;return n&&(l=l.negate()),o&&(u=u.negate()),u=new JacobianPoint(mod(u.x*f.beta),u.y,u.z),l.add(u)}precomputeWindow(e){let t=h?128/e+1:256/e+1,r=[],n=this,i=n;for(let o=0;o<t;o++){i=n,r.push(i);for(let t=1;t<2**(e-1);t++)i=i.add(n),r.push(i);n=i.double()}return r}wNAF(e,t){!t&&this.equals(JacobianPoint.BASE)&&(t=Point.BASE);let r=t&&t._WINDOW_SIZE||1;if(256%r)throw Error("Point#wNAF: Invalid precomputation window, must be power of 2");let n=t&&y.get(t);!n&&(n=this.precomputeWindow(r),t&&1!==r&&(n=JacobianPoint.normalizeZ(n),y.set(t,n)));let i=JacobianPoint.ZERO,o=JacobianPoint.BASE,a=1+(h?128/r:256/r),c=2**(r-1),l=BigInt(2**r-1),u=2**r,d=BigInt(r);for(let t=0;t<a;t++){let r=t*c,a=Number(e&l);e>>=d,a>c&&(a-=u,e+=s);let f=r+Math.abs(a)-1,h=t%2!=0,y=a<0;0===a?o=o.add(constTimeNegate(h,n[r])):i=i.add(constTimeNegate(y,n[f]))}return{p:i,f:o}}multiply(e,t){let r,n,i=normalizeScalar(e);if(h){let{k1neg:e,k1:o,k2neg:a,k2:s}=f.splitScalar(i),{p:c,f:l}=this.wNAF(o,t),{p:u,f:d}=this.wNAF(s,t);c=constTimeNegate(e,c),u=constTimeNegate(a,u),u=new JacobianPoint(mod(u.x*f.beta),u.y,u.z),r=c.add(u),n=l.add(d)}else{let{p:e,f:o}=this.wNAF(i,t);r=e,n=o}return JacobianPoint.normalizeZ([r,n])[0]}toAffine(e){let{x:t,y:r,z:n}=this,i=this.equals(JacobianPoint.ZERO);null==e&&(e=i?u:invert(n));let o=e,a=mod(o*o),c=mod(a*o),l=mod(t*a),d=mod(r*c),f=mod(n*o);if(i)return Point.ZERO;if(f!==s)throw Error("invZ was invalid");return new Point(l,d)}};function constTimeNegate(e,t){let r=t.negate();return e?r:t}JacobianPoint.BASE=new JacobianPoint(d.Gx,d.Gy,s),JacobianPoint.ZERO=new JacobianPoint(a,s,a);let y=new WeakMap;let Point=class Point{constructor(e,t){this.x=e,this.y=t}_setWindowSize(e){this._WINDOW_SIZE=e,y.delete(this)}hasEvenY(){return this.y%c===a}static fromCompressedHex(e){let t=32===e.length,r=bytesToNumber(t?e:e.subarray(1));if(!isValidFieldElement(r))throw Error("Point is not on curve");let n=weierstrass(r),i=function(e){let{P:t}=d,r=BigInt(6),n=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),s=BigInt(88),u=e*e*e%t,f=u*u*e%t,h=pow2(f,l)*f%t,y=pow2(h,l)*f%t,p=pow2(y,c)*u%t,g=pow2(p,n)*p%t,m=pow2(g,i)*g%t,b=pow2(m,a)*m%t,w=pow2(b,s)*b%t,v=pow2(w,a)*m%t,P=pow2(v,l)*f%t,S=pow2(P,o)*g%t,E=pow2(S,r)*u%t,T=pow2(E,c);if(T*T%t!==e)throw Error("Cannot find square root");return T}(n),o=(i&s)===s;if(t)o&&(i=mod(-i));else{let t=(1&e[0])==1;t!==o&&(i=mod(-i))}let a=new Point(r,i);return a.assertValidity(),a}static fromUncompressedHex(e){let t=bytesToNumber(e.subarray(1,33)),r=bytesToNumber(e.subarray(33,65)),n=new Point(t,r);return n.assertValidity(),n}static fromHex(e){let t=ensureBytes(e),r=t.length,n=t[0];if(32===r||33===r&&(2===n||3===n))return this.fromCompressedHex(t);if(65===r&&4===n)return this.fromUncompressedHex(t);throw Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${r}`)}static fromPrivateKey(e){return Point.BASE.multiply(normalizePrivateKey(e))}static fromSignature(e,t,r){let{r:n,s:i}=normalizeSignature(t);if(![0,1,2,3].includes(r))throw Error("Cannot recover: invalid recovery bit");let o=truncateHash(ensureBytes(e)),{n:a}=d,s=2===r||3===r?n+a:n,c=invert(s,a),l=mod(-o*c,a),u=mod(i*c,a),f=1&r?"03":"02",h=Point.fromHex(f+numTo32bStr(s)),y=Point.BASE.multiplyAndAddUnsafe(h,l,u);if(!y)throw Error("Cannot recover signature: point at infinify");return y.assertValidity(),y}toRawBytes(e=!1){return hexToBytes(this.toHex(e))}toHex(e=!1){let t=numTo32bStr(this.x);if(!e)return`04${t}${numTo32bStr(this.y)}`;{let e=this.hasEvenY()?"02":"03";return`${e}${t}`}}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){let e="Point is not on elliptic curve",{x:t,y:r}=this;if(!isValidFieldElement(t)||!isValidFieldElement(r))throw Error(e);let n=mod(r*r),i=weierstrass(t);if(mod(n-i)!==a)throw Error(e)}equals(e){return this.x===e.x&&this.y===e.y}negate(){return new Point(this.x,mod(-this.y))}double(){return JacobianPoint.fromAffine(this).double().toAffine()}add(e){return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(e)).toAffine()}subtract(e){return this.add(e.negate())}multiply(e){return JacobianPoint.fromAffine(this).multiply(e,this).toAffine()}multiplyAndAddUnsafe(e,t,r){let n=JacobianPoint.fromAffine(this),i=t===a||t===s||this!==Point.BASE?n.multiplyUnsafe(t):n.multiply(t),o=JacobianPoint.fromAffine(e).multiplyUnsafe(r),c=i.add(o);return c.equals(JacobianPoint.ZERO)?void 0:c.toAffine()}};function sliceDER(e){return Number.parseInt(e[0],16)>=8?"00"+e:e}function parseDERInt(e){if(e.length<2||2!==e[0])throw Error(`Invalid signature integer tag: ${bytesToHex(e)}`);let t=e[1],r=e.subarray(2,t+2);if(!t||r.length!==t)throw Error("Invalid signature integer: wrong length");if(0===r[0]&&r[1]<=127)throw Error("Invalid signature integer: trailing length");return{data:bytesToNumber(r),left:e.subarray(t+2)}}t.Point=Point,Point.BASE=new Point(d.Gx,d.Gy),Point.ZERO=new Point(a,a);let Signature=class Signature{constructor(e,t){this.r=e,this.s=t,this.assertValidity()}static fromCompact(e){let t=e instanceof Uint8Array,r="Signature.fromCompact";if("string"!=typeof e&&!t)throw TypeError(`${r}: Expected string or Uint8Array`);let n=t?bytesToHex(e):e;if(128!==n.length)throw Error(`${r}: Expected 64-byte hex`);return new Signature(hexToNumber(n.slice(0,64)),hexToNumber(n.slice(64,128)))}static fromDER(e){let t=e instanceof Uint8Array;if("string"!=typeof e&&!t)throw TypeError("Signature.fromDER: Expected string or Uint8Array");let{r,s:n}=function(e){if(e.length<2||48!=e[0])throw Error(`Invalid signature tag: ${bytesToHex(e)}`);if(e[1]!==e.length-2)throw Error("Invalid signature: incorrect length");let{data:t,left:r}=parseDERInt(e.subarray(2)),{data:n,left:i}=parseDERInt(r);if(i.length)throw Error(`Invalid signature: left bytes after parsing: ${bytesToHex(i)}`);return{r:t,s:n}}(t?e:hexToBytes(e));return new Signature(r,n)}static fromHex(e){return this.fromDER(e)}assertValidity(){let{r:e,s:t}=this;if(!isWithinCurveOrder(e))throw Error("Invalid Signature: r must be 0 < r < n");if(!isWithinCurveOrder(t))throw Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){let e=d.n>>s;return this.s>e}normalizeS(){return this.hasHighS()?new Signature(this.r,mod(-this.s,d.n)):this}toDERRawBytes(){return hexToBytes(this.toDERHex())}toDERHex(){let e=sliceDER(numberToHexUnpadded(this.s)),t=sliceDER(numberToHexUnpadded(this.r)),r=e.length/2,n=t.length/2,i=numberToHexUnpadded(r),o=numberToHexUnpadded(n),a=numberToHexUnpadded(n+r+4);return`30${a}02${o}${t}02${i}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return hexToBytes(this.toCompactHex())}toCompactHex(){return numTo32bStr(this.r)+numTo32bStr(this.s)}};function concatBytes(...e){if(!e.every(e=>e instanceof Uint8Array))throw Error("Uint8Array list expected");if(1===e.length)return e[0];let t=e.reduce((e,t)=>e+t.length,0),r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){let i=e[t];r.set(i,n),n+=i.length}return r}t.Signature=Signature;let p=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function bytesToHex(e){if(!(e instanceof Uint8Array))throw Error("Expected Uint8Array");let t="";for(let r=0;r<e.length;r++)t+=p[e[r]];return t}let g=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function numTo32bStr(e){if("bigint"!=typeof e)throw Error("Expected bigint");if(!(a<=e&&e<g))throw Error("Expected number 0 <= n < 2^256");return e.toString(16).padStart(64,"0")}function numTo32b(e){let t=hexToBytes(numTo32bStr(e));if(32!==t.length)throw Error("Error: expected 32 bytes");return t}function numberToHexUnpadded(e){let t=e.toString(16);return 1&t.length?`0${t}`:t}function hexToNumber(e){if("string"!=typeof e)throw TypeError("hexToNumber: expected string, got "+typeof e);return BigInt(`0x${e}`)}function hexToBytes(e){if("string"!=typeof e)throw TypeError("hexToBytes: expected string, got "+typeof e);if(e.length%2)throw Error("hexToBytes: received invalid unpadded hex"+e.length);let t=new Uint8Array(e.length/2);for(let r=0;r<t.length;r++){let n=2*r,i=e.slice(n,n+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw Error("Invalid byte sequence");t[r]=o}return t}function bytesToNumber(e){return hexToNumber(bytesToHex(e))}function ensureBytes(e){return e instanceof Uint8Array?Uint8Array.from(e):hexToBytes(e)}function normalizeScalar(e){if("number"==typeof e&&Number.isSafeInteger(e)&&e>0)return BigInt(e);if("bigint"==typeof e&&isWithinCurveOrder(e))return e;throw TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function mod(e,t=d.P){let r=e%t;return r>=a?r:t+r}function pow2(e,t){let{P:r}=d,n=e;for(;t-- >a;)n*=n,n%=r;return n}function invert(e,t=d.P){if(e===a||t<=a)throw Error(`invert: expected positive integers, got n=${e} mod=${t}`);let r=mod(e,t),n=t,i=a,o=s,c=s,l=a;for(;r!==a;){let e=n/r,t=n%r,a=i-c*e,s=o-l*e;n=r,r=t,i=c,o=l,c=a,l=s}let u=n;if(u!==s)throw Error("invert: does not exist");return mod(i,t)}function truncateHash(e,t=!1){let r=function(e){let t=8*e.length-256,r=bytesToNumber(e);return t>0?r>>BigInt(t):r}(e);if(t)return r;let{n}=d;return r>=n?r-n:r}let HmacDrbg=class HmacDrbg{constructor(e,t){if(this.hashLen=e,this.qByteLen=t,"number"!=typeof e||e<2)throw Error("hashLen must be a number");if("number"!=typeof t||t<2)throw Error("qByteLen must be a number");this.v=new Uint8Array(e).fill(1),this.k=new Uint8Array(e).fill(0),this.counter=0}hmac(...e){return t.utils.hmacSha256(this.k,...e)}hmacSync(...e){return i(this.k,...e)}checkSync(){if("function"!=typeof i)throw new ShaError("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(e=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),e),this.v=await this.hmac(this.v),0!==e.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),e),this.v=await this.hmac(this.v))}reseedSync(e=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),e),this.v=this.hmacSync(this.v),0!==e.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),e),this.v=this.hmacSync(this.v))}async generate(){this.incr();let e=0,t=[];for(;e<this.qByteLen;){this.v=await this.hmac(this.v);let r=this.v.slice();t.push(r),e+=this.v.length}return concatBytes(...t)}generateSync(){this.checkSync(),this.incr();let e=0,t=[];for(;e<this.qByteLen;){this.v=this.hmacSync(this.v);let r=this.v.slice();t.push(r),e+=this.v.length}return concatBytes(...t)}};function isWithinCurveOrder(e){return a<e&&e<d.n}function isValidFieldElement(e){return a<e&&e<d.P}function kmdToSig(e,t,r,n=!0){let{n:i}=d,o=truncateHash(e,!0);if(!isWithinCurveOrder(o))return;let c=invert(o,i),l=Point.BASE.multiply(o),u=mod(l.x,i);if(u===a)return;let f=mod(c*mod(t+r*u,i),i);if(f===a)return;let h=new Signature(u,f),y=(l.x===h.r?0:2)|Number(l.y&s);return n&&h.hasHighS()&&(h=h.normalizeS(),y^=1),{sig:h,recovery:y}}function normalizePrivateKey(e){let t;if("bigint"==typeof e)t=e;else if("number"==typeof e&&Number.isSafeInteger(e)&&e>0)t=BigInt(e);else if("string"==typeof e){if(64!==e.length)throw Error("Expected 32 bytes of private key");t=hexToNumber(e)}else if(e instanceof Uint8Array){if(32!==e.length)throw Error("Expected 32 bytes of private key");t=bytesToNumber(e)}else throw TypeError("Expected valid private key");if(!isWithinCurveOrder(t))throw Error("Expected private key: 0 < key < n");return t}function normalizePublicKey(e){return e instanceof Point?(e.assertValidity(),e):Point.fromHex(e)}function normalizeSignature(e){if(e instanceof Signature)return e.assertValidity(),e;try{return Signature.fromDER(e)}catch(t){return Signature.fromCompact(e)}}function isProbPub(e){let t=e instanceof Uint8Array,r="string"==typeof e,n=(t||r)&&e.length;return t?33===n||65===n:r?66===n||130===n:e instanceof Point}function bits2int(e){let t=e.length>32?e.slice(0,32):e;return bytesToNumber(t)}function initSigArgs(e,r,n){if(null==e)throw Error(`sign: expected valid message hash, not "${e}"`);let i=ensureBytes(e),o=normalizePrivateKey(r),s=[numTo32b(o),function(e){var t;let r=bits2int(e),n=mod(r,d.n);return numTo32b(n<a?r:n)}(i)];if(null!=n){!0===n&&(n=t.utils.randomBytes(32));let e=ensureBytes(n);if(32!==e.length)throw Error("sign: Expected 32 bytes of extra data");s.push(e)}let c=concatBytes(...s),l=bits2int(i);return{seed:c,m:l,d:o}}function finalizeSig(e,t){let{sig:r,recovery:n}=e,{der:i,recovered:o}=Object.assign({canonical:!0,der:!0},t),a=i?r.toDERRawBytes():r.toCompactRawBytes();return o?[a,n]:a}async function sign(e,t,r={}){let n;let{seed:i,m:o,d:a}=initSigArgs(e,t,r.extraEntropy),s=new HmacDrbg(32,32);for(await s.reseed(i);!(n=kmdToSig(await s.generate(),o,a,r.canonical));)await s.reseed();return finalizeSig(n,r)}t.getPublicKey=function(e,t=!1){return Point.fromPrivateKey(e).toRawBytes(t)},t.recoverPublicKey=function(e,t,r,n=!1){return Point.fromSignature(e,t,r).toRawBytes(n)},t.getSharedSecret=function(e,t,r=!1){if(isProbPub(e))throw TypeError("getSharedSecret: first arg must be private key");if(!isProbPub(t))throw TypeError("getSharedSecret: second arg must be public key");let n=normalizePublicKey(t);return n.assertValidity(),n.multiply(normalizePrivateKey(e)).toRawBytes(r)},t.sign=sign,t.signSync=function(e,t,r={}){let n;let{seed:i,m:o,d:a}=initSigArgs(e,t,r.extraEntropy),s=new HmacDrbg(32,32);for(s.reseedSync(i);!(n=kmdToSig(s.generateSync(),o,a,r.canonical));)s.reseedSync();return finalizeSig(n,r)};let m={strict:!0};function schnorrChallengeFinalize(e){return mod(bytesToNumber(e),d.n)}t.verify=function(e,t,r,n=m){let i,o;try{i=normalizeSignature(e),t=ensureBytes(t)}catch(e){return!1}let{r:a,s}=i;if(n.strict&&i.hasHighS())return!1;let c=truncateHash(t);try{o=normalizePublicKey(r)}catch(e){return!1}let{n:l}=d,u=invert(s,l),f=mod(c*u,l),h=mod(a*u,l),y=Point.BASE.multiplyAndAddUnsafe(o,f,h);if(!y)return!1;let p=mod(y.x,l);return p===a};let SchnorrSignature=class SchnorrSignature{constructor(e,t){this.r=e,this.s=t,this.assertValidity()}static fromHex(e){let t=ensureBytes(e);if(64!==t.length)throw TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${t.length}`);let r=bytesToNumber(t.subarray(0,32)),n=bytesToNumber(t.subarray(32,64));return new SchnorrSignature(r,n)}assertValidity(){let{r:e,s:t}=this;if(!isValidFieldElement(e)||!isWithinCurveOrder(t))throw Error("Invalid signature")}toHex(){return numTo32bStr(this.r)+numTo32bStr(this.s)}toRawBytes(){return hexToBytes(this.toHex())}};let InternalSchnorrSignature=class InternalSchnorrSignature{constructor(e,r,n=t.utils.randomBytes()){if(null==e)throw TypeError(`sign: Expected valid message, not "${e}"`);this.m=ensureBytes(e);let{x:i,scalar:o}=this.getScalar(normalizePrivateKey(r));if(this.px=i,this.d=o,this.rand=ensureBytes(n),32!==this.rand.length)throw TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(e){let t=Point.fromPrivateKey(e),r=t.hasEvenY()?e:d.n-e;return{point:t,scalar:r,x:t.toRawX()}}initNonce(e,t){return numTo32b(e^bytesToNumber(t))}finalizeNonce(e){let t=mod(bytesToNumber(e),d.n);if(t===a)throw Error("sign: Creation of signature failed. k is zero");let{point:r,x:n,scalar:i}=this.getScalar(t);return{R:r,rx:n,k:i}}finalizeSig(e,t,r,n){return new SchnorrSignature(e.x,mod(t+r*n,d.n)).toRawBytes()}error(){throw Error("sign: Invalid signature produced")}async calc(){let{m:e,d:r,px:n,rand:i}=this,o=t.utils.taggedHash,a=this.initNonce(r,await o(w.aux,i)),{R:s,rx:c,k:l}=this.finalizeNonce(await o(w.nonce,a,n,e)),u=schnorrChallengeFinalize(await o(w.challenge,c,n,e)),d=this.finalizeSig(s,l,u,r);return await schnorrVerify(d,e,n)||this.error(),d}calcSync(){let{m:e,d:r,px:n,rand:i}=this,o=t.utils.taggedHashSync,a=this.initNonce(r,o(w.aux,i)),{R:s,rx:c,k:l}=this.finalizeNonce(o(w.nonce,a,n,e)),u=schnorrChallengeFinalize(o(w.challenge,c,n,e)),d=this.finalizeSig(s,l,u,r);return schnorrVerifySync(d,e,n)||this.error(),d}};async function schnorrSign(e,t,r){return new InternalSchnorrSignature(e,t,r).calc()}function initSchnorrVerify(e,t,r){let n=e instanceof SchnorrSignature,i=n?e:SchnorrSignature.fromHex(e);return n&&i.assertValidity(),{...i,m:ensureBytes(t),P:normalizePublicKey(r)}}function finalizeSchnorrVerify(e,t,r,n){let i=Point.BASE.multiplyAndAddUnsafe(t,normalizePrivateKey(r),mod(-n,d.n));return!!(i&&i.hasEvenY())&&i.x===e}async function schnorrVerify(e,r,n){try{let{r:i,s:o,m:a,P:s}=initSchnorrVerify(e,r,n),c=schnorrChallengeFinalize(await t.utils.taggedHash(w.challenge,numTo32b(i),s.toRawX(),a));return finalizeSchnorrVerify(i,s,o,c)}catch(e){return!1}}function schnorrVerifySync(e,r,n){try{let{r:i,s:o,m:a,P:s}=initSchnorrVerify(e,r,n),c=schnorrChallengeFinalize(t.utils.taggedHashSync(w.challenge,numTo32b(i),s.toRawX(),a));return finalizeSchnorrVerify(i,s,o,c)}catch(e){if(e instanceof ShaError)throw e;return!1}}t.schnorr={Signature:SchnorrSignature,getPublicKey:function(e){return Point.fromPrivateKey(e).toRawX()},sign:schnorrSign,verify:schnorrVerify,signSync:function(e,t,r){return new InternalSchnorrSignature(e,t,r).calcSync()},verifySync:schnorrVerifySync},Point.BASE._setWindowSize(8);let b={node:o,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},w={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},v={};t.utils={bytesToHex,hexToBytes,concatBytes,mod,invert,isValidPrivateKey(e){try{return normalizePrivateKey(e),!0}catch(e){return!1}},_bigintTo32Bytes:numTo32b,_normalizePrivateKey:normalizePrivateKey,hashToPrivateKey:e=>{if((e=ensureBytes(e)).length<40||e.length>1024)throw Error("Expected valid bytes of private key as per FIPS 186");let t=mod(bytesToNumber(e),d.n-s)+s;return numTo32b(t)},randomBytes:(e=32)=>{if(b.web)return b.web.getRandomValues(new Uint8Array(e));if(b.node){let{randomBytes:t}=b.node;return Uint8Array.from(t(e))}throw Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>t.utils.hashToPrivateKey(t.utils.randomBytes(40)),precompute(e=8,t=Point.BASE){let r=t===Point.BASE?t:new Point(t.x,t.y);return r._setWindowSize(e),r.multiply(l),r},sha256:async(...e)=>{if(b.web){let t=await b.web.subtle.digest("SHA-256",concatBytes(...e));return new Uint8Array(t)}if(b.node){let{createHash:t}=b.node,r=t("sha256");return e.forEach(e=>r.update(e)),Uint8Array.from(r.digest())}throw Error("The environment doesn't have sha256 function")},hmacSha256:async(e,...t)=>{if(b.web){let r=await b.web.subtle.importKey("raw",e,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),n=concatBytes(...t),i=await b.web.subtle.sign("HMAC",r,n);return new Uint8Array(i)}if(b.node){let{createHmac:r}=b.node,n=r("sha256",e);return t.forEach(e=>n.update(e)),Uint8Array.from(n.digest())}throw Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(e,...r)=>{let n=v[e];if(void 0===n){let r=await t.utils.sha256(Uint8Array.from(e,e=>e.charCodeAt(0)));n=concatBytes(r,r),v[e]=n}return t.utils.sha256(n,...r)},taggedHashSync:(e,...t)=>{if("function"!=typeof n)throw new ShaError("sha256Sync is undefined, you need to set it");let r=v[e];if(void 0===r){let t=n(Uint8Array.from(e,e=>e.charCodeAt(0)));r=concatBytes(t,t),v[e]=r}return n(r,...t)},_JacobianPoint:JacobianPoint},Object.defineProperties(t.utils,{sha256Sync:{configurable:!1,get:()=>n,set(e){n||(n=e)}},hmacSha256Sync:{configurable:!1,get:()=>i,set(e){i||(i=e)}}})},55674:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.decode=t.encode=t.unescape=t.escape=t.pad=void 0;let n=r(34699);function pad(e){return`${e}${"=".repeat(4-(e.length%4||4))}`}function escape(e){return e.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function unescape(e){return pad(e).replace(/-/g,"+").replace(/_/g,"/")}t.pad=pad,t.escape=escape,t.unescape=unescape,t.encode=function(e){return escape((0,n.fromByteArray)(new TextEncoder().encode(e)))},t.decode=function(e){return new TextDecoder().decode((0,n.toByteArray)(pad(unescape(e))))}},35078:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.cryptoClients=t.SECP256K1Client=void 0;let n=r(72965);Object.defineProperty(t,"SECP256K1Client",{enumerable:!0,get:function(){return n.SECP256K1Client}});let i={ES256K:n.SECP256K1Client};t.cryptoClients=i},72965:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.SECP256K1Client=void 0;let n=r(34374),i=r(70035),o=r(45999),a=r(81192),s=r(31474),c=r(17452);o.utils.hmacSha256Sync=(e,...t)=>{let r=n.hmac.create(i.sha256,e);return t.forEach(e=>r.update(e)),r.digest()};let SECP256K1Client=class SECP256K1Client{static derivePublicKey(e,t=!0){return 66===e.length&&(e=e.slice(0,64)),e.length<64&&(e=e.padStart(64,"0")),(0,c.bytesToHex)(o.getPublicKey(e,t))}static signHash(e,t,r="jose"){if(!e||!t)throw new s.MissingParametersError("a signing input hash and private key are all required");let n=o.signSync(e,t.slice(0,64),{der:!0,canonical:!1});if("der"===r)return(0,c.bytesToHex)(n);if("jose"===r)return(0,a.derToJose)(n,"ES256");throw Error("Invalid signature format")}static loadSignature(e){return(0,a.joseToDer)(e,"ES256")}static verifyHash(e,t,r){if(!e||!t||!r)throw new s.MissingParametersError("a signing input hash, der signature, and public key are all required");return o.verify(t,e,r,{strict:!1})}};t.SECP256K1Client=SECP256K1Client,SECP256K1Client.algorithmName="ES256K"},85666:function(e,t,r){var n=this&&this.__awaiter||function(e,t,r,n){return new(r||(r=Promise))(function(i,o){function fulfilled(e){try{step(n.next(e))}catch(e){o(e)}}function rejected(e){try{step(n.throw(e))}catch(e){o(e)}}function step(e){var t;e.done?i(e.value):((t=e.value)instanceof r?t:new r(function(e){e(t)})).then(fulfilled,rejected)}step((n=n.apply(e,t||[])).next())})};Object.defineProperty(t,"__esModule",{value:!0}),t.hashSha256Async=t.hashSha256=void 0;let i=r(70035);function hashSha256(e){return(0,i.sha256)(e)}t.hashSha256=hashSha256,t.hashSha256Async=function(e){return n(this,void 0,void 0,function*(){try{let t="undefined"!=typeof crypto&&void 0!==crypto.subtle;if(t){let t="string"==typeof e?new TextEncoder().encode(e):e,r=yield crypto.subtle.digest("SHA-256",t);return new Uint8Array(r)}{let t=r(18971);if(!t.createHash)throw Error("`crypto` module does not contain `createHash`");return Promise.resolve(t.createHash("sha256").update(e).digest())}}catch(t){return console.log(t),console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'),Promise.resolve(hashSha256(e))}})}},28063:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.decodeToken=void 0;let n=r(55674);t.decodeToken=function(e){if("string"==typeof e){let t=e.split("."),r=JSON.parse(n.decode(t[0])),i=JSON.parse(n.decode(t[1])),o=t[2];return{header:r,payload:i,signature:o}}if("object"==typeof e){if("string"!=typeof e.payload)throw Error("Expected token payload to be a base64 or json string");let t=e.payload;"{"!==e.payload[0]&&(t=n.decode(t));let r=[];return e.header.map(e=>{let t=JSON.parse(n.decode(e));r.push(t)}),{header:r,payload:JSON.parse(t),signature:e.signature}}}},81192:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.joseToDer=t.derToJose=void 0;let n=r(34699),i=r(55674);function getParamSize(e){return(e/8|0)+(e%8==0?0:1)}let o={ES256:getParamSize(256),ES384:getParamSize(384),ES512:getParamSize(521)};function getParamBytesForAlg(e){let t=o[e];if(t)return t;throw Error(`Unknown algorithm "${e}"`)}function signatureAsBytes(e){if(e instanceof Uint8Array)return e;if("string"==typeof e)return(0,n.toByteArray)((0,i.pad)(e));throw TypeError("ECDSA signature must be a Base64 string or a Uint8Array")}function countPadding(e,t,r){let n=0;for(;t+n<r&&0===e[t+n];)++n;let i=e[t+n]>=128;return i&&--n,n}t.derToJose=function(e,t){let r=signatureAsBytes(e),o=getParamBytesForAlg(t),a=o+1,s=r.length,c=0;if(48!==r[c++])throw Error('Could not find expected "seq"');let l=r[c++];if(129===l&&(l=r[c++]),s-c<l)throw Error(`"seq" specified length of "${l}", only "${s-c}" remaining`);if(2!==r[c++])throw Error('Could not find expected "int" for "r"');let u=r[c++];if(s-c-2<u)throw Error(`"r" specified length of "${u}", only "${s-c-2}" available`);if(a<u)throw Error(`"r" specified length of "${u}", max of "${a}" is acceptable`);let d=c;if(c+=u,2!==r[c++])throw Error('Could not find expected "int" for "s"');let f=r[c++];if(s-c!==f)throw Error(`"s" specified length of "${f}", expected "${s-c}"`);if(a<f)throw Error(`"s" specified length of "${f}", max of "${a}" is acceptable`);let h=c;if((c+=f)!==s)throw Error(`Expected to consume entire array, but "${s-c}" bytes remain`);let y=o-u,p=o-f,g=new Uint8Array(y+u+p+f);for(c=0;c<y;++c)g[c]=0;g.set(r.subarray(d+Math.max(-y,0),d+u),c),c=o;for(let e=c;c<e+p;++c)g[c]=0;return g.set(r.subarray(h+Math.max(-p,0),h+f),c),(0,i.escape)((0,n.fromByteArray)(g))},t.joseToDer=function(e,t){e=signatureAsBytes(e);let r=getParamBytesForAlg(t),n=e.length;if(n!==2*r)throw TypeError(`"${t}" signatures must be "${2*r}" bytes, saw "${n}"`);let i=countPadding(e,0,r),o=countPadding(e,r,e.length),a=r-i,s=r-o,c=2+a+1+1+s,l=c<128,u=new Uint8Array((l?2:3)+c),d=0;return u[d++]=48,l?u[d++]=c:(u[d++]=129,u[d++]=255&c),u[d++]=2,u[d++]=a,i<0?(u[d++]=0,u.set(e.subarray(0,r),d),d+=r):(u.set(e.subarray(i,r),d),d+=r-i),u[d++]=2,u[d++]=s,o<0?(u[d++]=0,u.set(e.subarray(r),d)):u.set(e.subarray(r+o),d),u}},31474:function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.InvalidTokenError=t.MissingParametersError=void 0,t.MissingParametersError=class extends Error{constructor(e){super(),this.name="MissingParametersError",this.message=e||""}},t.InvalidTokenError=class extends Error{constructor(e){super(),this.name="InvalidTokenError",this.message=e||""}}},23139:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);(!i||("get"in i?!t.__esModule:i.writable||i.configurable))&&(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),i(r(83455),t),i(r(31567),t),i(r(28063),t),i(r(31474),t),i(r(35078),t)},83455:function(e,t,r){var n=this&&this.__awaiter||function(e,t,r,n){return new(r||(r=Promise))(function(i,o){function fulfilled(e){try{step(n.next(e))}catch(e){o(e)}}function rejected(e){try{step(n.throw(e))}catch(e){o(e)}}function step(e){var t;e.done?i(e.value):((t=e.value)instanceof r?t:new r(function(e){e(t)})).then(fulfilled,rejected)}step((n=n.apply(e,t||[])).next())})};Object.defineProperty(t,"__esModule",{value:!0}),t.TokenSigner=t.createUnsecuredToken=void 0;let i=r(55674),o=r(35078),a=r(31474),s=r(85666);function createSigningInput(e,t){let r=[],n=i.encode(JSON.stringify(t));r.push(n);let o=i.encode(JSON.stringify(e));r.push(o);let a=r.join(".");return a}t.createUnsecuredToken=function(e){return createSigningInput(e,{typ:"JWT",alg:"none"})+"."},t.TokenSigner=class{constructor(e,t){if(!(e&&t))throw new a.MissingParametersError("a signing algorithm and private key are required");if("string"!=typeof e)throw Error("signing algorithm parameter must be a string");if(e=e.toUpperCase(),!o.cryptoClients.hasOwnProperty(e))throw Error("invalid signing algorithm");this.tokenType="JWT",this.cryptoClient=o.cryptoClients[e],this.rawPrivateKey=t}header(e={}){let t={typ:this.tokenType,alg:this.cryptoClient.algorithmName};return Object.assign({},t,e)}sign(e,t=!1,r={}){let n=this.header(r),i=createSigningInput(e,n),o=(0,s.hashSha256)(i);return this.createWithSignedHash(e,t,n,i,o)}signAsync(e,t=!1,r={}){return n(this,void 0,void 0,function*(){let n=this.header(r),i=createSigningInput(e,n),o=yield(0,s.hashSha256Async)(i);return this.createWithSignedHash(e,t,n,i,o)})}createWithSignedHash(e,t,r,n,o){let a=this.cryptoClient.signHash(o,this.rawPrivateKey);if(!t)return[n,a].join(".");{let t={header:[i.encode(JSON.stringify(r))],payload:JSON.stringify(e),signature:[a]};return t}}}},31567:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.TokenVerifier=void 0;let n=r(55674),i=r(35078),o=r(31474),a=r(85666);t.TokenVerifier=class{constructor(e,t){if(!(e&&t))throw new o.MissingParametersError("a signing algorithm and public key are required");if("string"!=typeof e)throw"signing algorithm parameter must be a string";if(e=e.toUpperCase(),!i.cryptoClients.hasOwnProperty(e))throw"invalid signing algorithm";this.tokenType="JWT",this.cryptoClient=i.cryptoClients[e],this.rawPublicKey=t}verify(e){return"string"==typeof e?this.verifyCompact(e,!1):"object"==typeof e&&this.verifyExpanded(e,!1)}verifyAsync(e){return"string"==typeof e?this.verifyCompact(e,!0):"object"==typeof e?this.verifyExpanded(e,!0):Promise.resolve(!1)}verifyCompact(e,t){let r=e.split("."),n=r[0]+"."+r[1],performVerify=e=>{let t=this.cryptoClient.loadSignature(r[2]);return this.cryptoClient.verifyHash(e,t,this.rawPublicKey)};if(t)return(0,a.hashSha256Async)(n).then(e=>performVerify(e));{let e=(0,a.hashSha256)(n);return performVerify(e)}}verifyExpanded(e,t){let r=[e.header.join("."),n.encode(e.payload)].join("."),i=!0,performVerify=t=>(e.signature.map(e=>{let r=this.cryptoClient.loadSignature(e),n=this.cryptoClient.verifyHash(t,r,this.rawPublicKey);n||(i=!1)}),i);if(t)return(0,a.hashSha256Async)(r).then(e=>performVerify(e));{let e=(0,a.hashSha256)(r);return performVerify(e)}}}},45883:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);(!i||("get"in i?!t.__esModule:i.writable||i.configurable))&&(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.getAddress=void 0;let o=r(23139),a=r(41365),getAddress=async e=>{let t=await (0,a.getProviderOrThrow)(e.getProvider),{purposes:r}=e.payload;if(!r)throw Error("Address purposes are required");try{let r=(0,o.createUnsecuredToken)(e.payload),n=await t.connect(r);e.onFinish?.(n)}catch(t){console.error("[Connect] Error during address request",t),e.onCancel?.()}};t.getAddress=getAddress,i(r(63305),t)},63305:function(e,t){var r,n;Object.defineProperty(t,"__esModule",{value:!0}),t.AddressType=t.AddressPurpose=void 0,(r=t.AddressPurpose||(t.AddressPurpose={})).Ordinals="ordinals",r.Payment="payment",r.Stacks="stacks",(n=t.AddressType||(t.AddressType={})).p2pkh="p2pkh",n.p2sh="p2sh",n.p2wpkh="p2wpkh",n.p2wsh="p2wsh",n.p2tr="p2tr",n.stacks="stacks"},60361:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);(!i||("get"in i?!t.__esModule:i.writable||i.configurable))&&(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.callWalletPopup=void 0;let o=r(23139),a=r(41365),callWalletPopup=async e=>{let t=await (0,a.getProviderOrThrow)(e.getProvider),{method:r}=e.payload;if(!r)throw Error("A wallet method is required");let n=(0,o.createUnsecuredToken)(e.payload);try{let r=await t.call(n);e.onFinish?.(r)}catch(t){console.error("[Connect] Error during call request",t),e.onCancel?.()}};t.callWalletPopup=callWalletPopup,i(r(96106),t)},96106:function(e,t){Object.defineProperty(t,"__esModule",{value:!0})},16667:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);(!i||("get"in i?!t.__esModule:i.writable||i.configurable))&&(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.getCapabilities=void 0;let o=r(23139),a=r(41365),extractOrValidateCapabilities=(e,t)=>{let validateCapability=r=>!!(e[r]&&(!t||t.has(r))),r={call:validateCapability("call"),connect:validateCapability("connect"),signMessage:validateCapability("signMessage"),signTransaction:validateCapability("signTransaction"),sendBtcTransaction:validateCapability("sendBtcTransaction"),createInscription:validateCapability("createInscription"),createRepeatInscriptions:validateCapability("createRepeatInscriptions"),signMultipleTransactions:validateCapability("signMultipleTransactions")};return Object.entries(r).reduce((e,[t,r])=>r?[...e,t]:e,[])},getCapabilities=async e=>{let t=await (0,a.getProviderOrThrow)(e.getProvider),r=(0,o.createUnsecuredToken)(e.payload);if(t.getCapabilities)try{let n=await t.getCapabilities(r);e.onFinish?.(extractOrValidateCapabilities(t,new Set(n)))}catch(e){console.error("[Connect] Error during capabilities request",e)}try{let r=extractOrValidateCapabilities(t);e.onFinish?.(r)}catch(t){console.error("[Connect] Error during capabilities request",t),e.onCancel?.()}};t.getCapabilities=getCapabilities,i(r(78386),t)},78386:function(e,t){Object.defineProperty(t,"__esModule",{value:!0})},83706:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);(!i||("get"in i?!t.__esModule:i.writable||i.configurable))&&(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),i(r(45883),t),i(r(60361),t),i(r(16667),t),i(r(72073),t),i(r(2971),t),i(r(41365),t),i(r(84118),t),i(r(1905),t)},90551:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.createInscription=void 0;let n=r(23139),i=r(41365),o=r(78049),createInscription=async e=>{let{getProvider:t}=e,r=await (0,i.getProviderOrThrow)(t);(0,o.validateInscriptionPayload)(e.payload);try{let t=(0,n.createUnsecuredToken)(e.payload),i=await r.createInscription(t);e.onFinish?.(i)}catch(t){console.error("[Connect] Error during create inscription",t),e.onCancel?.()}};t.createInscription=createInscription},44140:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.createRepeatInscriptions=void 0;let n=r(41365),i=r(23139),o=r(78049),createRepeatInscriptions=async e=>{let{getProvider:t}=e,r=await (0,n.getProviderOrThrow)(t);(0,o.validateInscriptionPayload)(e.payload);try{let t=(0,i.createUnsecuredToken)(e.payload),n=await r.createRepeatInscriptions(t);e.onFinish?.(n)}catch(t){console.error("[Connect] Error during create repeat inscriptions",t),e.onCancel?.()}};t.createRepeatInscriptions=createRepeatInscriptions},72073:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);(!i||("get"in i?!t.__esModule:i.writable||i.configurable))&&(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),i(r(90551),t),i(r(44140),t),i(r(89639),t)},89639:function(e,t){Object.defineProperty(t,"__esModule",{value:!0})},78049:function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.validateInscriptionPayload=void 0,t.validateInscriptionPayload=e=>{let{contentType:t,content:r,payloadType:n,network:i,appFeeAddress:o,appFee:a}=e;if(!/^[a-z]+\/[a-z0-9\-\.\+]+(?=;.*|$)/.test(t))throw Error("Invalid content type detected");if(!r||0===r.length)throw Error("Empty content not allowed");if(!n||"BASE_64"!==n&&"PLAIN_TEXT"!==n)throw Error("Empty invalid payloadType specified");if(r.length>("Mainnet"===i.type?4e5:6e4))throw Error("Content too large");if((o?.length??0)>0&&(a??0)<=0)throw Error("Invalid combination of app fee address and fee provided")}},2971:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);(!i||("get"in i?!t.__esModule:i.writable||i.configurable))&&(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.signMessage=void 0;let o=r(23139),a=r(41365),signMessage=async e=>{let t=await (0,a.getProviderOrThrow)(e.getProvider),{address:r,message:n}=e.payload;if(!r)throw Error("An address is required to sign a message");if(!n)throw Error("A message to be signed is required");try{let r=(0,o.createUnsecuredToken)(e.payload),n=await t.signMessage(r);e.onFinish?.(n)}catch(t){console.error("[Connect] Error during sign message request",t),e.onCancel?.()}};t.signMessage=signMessage,i(r(17842),t)},17842:function(e,t){Object.defineProperty(t,"__esModule",{value:!0})},41365:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);(!i||("get"in i?!t.__esModule:i.writable||i.configurable))&&(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};async function getProviderOrThrow(e){let t=await e?.()||window.XverseProviders?.BitcoinProvider||window.BitcoinProvider;if(!t)throw Error("No Bitcoin wallet installed");return t}Object.defineProperty(t,"__esModule",{value:!0}),t.getProviderOrThrow=void 0,t.getProviderOrThrow=getProviderOrThrow,i(r(83700),t)},83700:function(e,t){Object.defineProperty(t,"__esModule",{value:!0})},84118:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);(!i||("get"in i?!t.__esModule:i.writable||i.configurable))&&(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),i(r(8828),t),i(r(70740),t),i(r(63876),t),i(r(54307),t)},8828:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.sendBtcTransaction=void 0;let n=r(23139),i=r(41365),serializer=e=>e.map(e=>{let{address:t,amountSats:r}=e;return{address:t,amountSats:r.toString()}}),sendBtcTransaction=async e=>{let t=await (0,i.getProviderOrThrow)(e.getProvider),{recipients:r,senderAddress:o,network:a,message:s}=e.payload;if(!r||0===r.length)throw Error("At least one recipient is required");if(r.some(e=>"string"!=typeof e.address||"bigint"!=typeof e.amountSats))throw Error("Incorrect recipient format");if(!o)throw Error("The sender address is required");try{let i=serializer(r),c=(0,n.createUnsecuredToken)({network:a,senderAddress:o,message:s,recipients:i}),l=await t.sendBtcTransaction(c);e.onFinish?.(l)}catch(t){console.error("[Connect] Error during send BTC transaction request",t),e.onCancel?.()}};t.sendBtcTransaction=sendBtcTransaction},63876:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.signMultipleTransactions=void 0;let n=r(23139),i=r(41365),signMultipleTransactions=async e=>{let t=await (0,i.getProviderOrThrow)(e.getProvider),{psbts:r}=e.payload;if(!r||!r.length)throw Error("psbts array is required");if(r.length>100)throw Error("psbts array must contain less than 100 psbts");try{let r=(0,n.createUnsecuredToken)(e.payload),i=await t.signMultipleTransactions(r);e.onFinish?.(i)}catch(t){console.error("[Connect] Error during sign Multiple transactions request",t),e.onCancel?.()}};t.signMultipleTransactions=signMultipleTransactions},70740:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.signTransaction=void 0;let n=r(23139),i=r(41365),signTransaction=async e=>{let t=await (0,i.getProviderOrThrow)(e.getProvider),{psbtBase64:r,inputsToSign:o}=e.payload;if(!r)throw Error("A value for psbtBase64 representing the tx hash is required");if(!o)throw Error("An array specifying the inputs to be signed by the wallet is required");try{let r=(0,n.createUnsecuredToken)(e.payload),i=await t.signTransaction(r);e.onFinish?.(i)}catch(t){console.error("[Connect] Error during sign transaction request",t),e.onCancel?.()}};t.signTransaction=signTransaction},54307:function(e,t){Object.defineProperty(t,"__esModule",{value:!0})},1905:function(e,t){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.BitcoinNetworkType=void 0,(r=t.BitcoinNetworkType||(t.BitcoinNetworkType={})).Mainnet="Mainnet",r.Testnet="Testnet"}}]);